{"ast":null,"code":"/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\n(function (global) {\n  \"use strict\"; // Top level module for the global, static logger instance.\n\n  var Logger = {}; // For those that are at home that are keeping score.\n\n  Logger.VERSION = \"1.6.1\"; // Function which handles all incoming log messages.\n\n  var logHandler; // Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\n\n  var contextualLoggersByNameMap = {}; // Polyfill for ES5's Function.bind.\n\n  var bind = function bind(scope, func) {\n    return function () {\n      return func.apply(scope, arguments);\n    };\n  }; // Super exciting object merger-matron 9000 adding another 100 bytes to your download.\n\n\n  var merge = function merge() {\n    var args = arguments,\n        target = args[0],\n        key,\n        i;\n\n    for (i = 1; i < args.length; i++) {\n      for (key in args[i]) {\n        if (!(key in target) && args[i].hasOwnProperty(key)) {\n          target[key] = args[i][key];\n        }\n      }\n    }\n\n    return target;\n  }; // Helper to define a logging level object; helps with optimisation.\n\n\n  var defineLogLevel = function defineLogLevel(value, name) {\n    return {\n      value: value,\n      name: name\n    };\n  }; // Predefined logging levels.\n\n\n  Logger.TRACE = defineLogLevel(1, 'TRACE');\n  Logger.DEBUG = defineLogLevel(2, 'DEBUG');\n  Logger.INFO = defineLogLevel(3, 'INFO');\n  Logger.TIME = defineLogLevel(4, 'TIME');\n  Logger.WARN = defineLogLevel(5, 'WARN');\n  Logger.ERROR = defineLogLevel(8, 'ERROR');\n  Logger.OFF = defineLogLevel(99, 'OFF'); // Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\n  // of each other.\n\n  var ContextualLogger = function ContextualLogger(defaultContext) {\n    this.context = defaultContext;\n    this.setLevel(defaultContext.filterLevel);\n    this.log = this.info; // Convenience alias.\n  };\n\n  ContextualLogger.prototype = {\n    // Changes the current logging level for the logging instance.\n    setLevel: function setLevel(newLevel) {\n      // Ensure the supplied Level object looks valid.\n      if (newLevel && \"value\" in newLevel) {\n        this.context.filterLevel = newLevel;\n      }\n    },\n    // Gets the current logging level for the logging instance\n    getLevel: function getLevel() {\n      return this.context.filterLevel;\n    },\n    // Is the logger configured to output messages at the supplied level?\n    enabledFor: function enabledFor(lvl) {\n      var filterLevel = this.context.filterLevel;\n      return lvl.value >= filterLevel.value;\n    },\n    trace: function trace() {\n      this.invoke(Logger.TRACE, arguments);\n    },\n    debug: function debug() {\n      this.invoke(Logger.DEBUG, arguments);\n    },\n    info: function info() {\n      this.invoke(Logger.INFO, arguments);\n    },\n    warn: function warn() {\n      this.invoke(Logger.WARN, arguments);\n    },\n    error: function error() {\n      this.invoke(Logger.ERROR, arguments);\n    },\n    time: function time(label) {\n      if (typeof label === 'string' && label.length > 0) {\n        this.invoke(Logger.TIME, [label, 'start']);\n      }\n    },\n    timeEnd: function timeEnd(label) {\n      if (typeof label === 'string' && label.length > 0) {\n        this.invoke(Logger.TIME, [label, 'end']);\n      }\n    },\n    // Invokes the logger callback if it's not being filtered.\n    invoke: function invoke(level, msgArgs) {\n      if (logHandler && this.enabledFor(level)) {\n        logHandler(msgArgs, merge({\n          level: level\n        }, this.context));\n      }\n    }\n  }; // Protected instance which all calls to the to level `Logger` module will be routed through.\n\n  var globalLogger = new ContextualLogger({\n    filterLevel: Logger.OFF\n  }); // Configure the global Logger instance.\n\n  (function () {\n    // Shortcut for optimisers.\n    var L = Logger;\n    L.enabledFor = bind(globalLogger, globalLogger.enabledFor);\n    L.trace = bind(globalLogger, globalLogger.trace);\n    L.debug = bind(globalLogger, globalLogger.debug);\n    L.time = bind(globalLogger, globalLogger.time);\n    L.timeEnd = bind(globalLogger, globalLogger.timeEnd);\n    L.info = bind(globalLogger, globalLogger.info);\n    L.warn = bind(globalLogger, globalLogger.warn);\n    L.error = bind(globalLogger, globalLogger.error); // Don't forget the convenience alias!\n\n    L.log = L.info;\n  })(); // Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\n  // object with the supplied log messages and the second being a context object which contains a hash of stateful\n  // parameters which the logging function can consume.\n\n\n  Logger.setHandler = function (func) {\n    logHandler = func;\n  }; // Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\n  // (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\n\n\n  Logger.setLevel = function (level) {\n    // Set the globalLogger's level.\n    globalLogger.setLevel(level); // Apply this level to all registered contextual loggers.\n\n    for (var key in contextualLoggersByNameMap) {\n      if (contextualLoggersByNameMap.hasOwnProperty(key)) {\n        contextualLoggersByNameMap[key].setLevel(level);\n      }\n    }\n  }; // Gets the global logging filter level\n\n\n  Logger.getLevel = function () {\n    return globalLogger.getLevel();\n  }; // Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\n  // default context and log handler.\n\n\n  Logger.get = function (name) {\n    // All logger instances are cached so they can be configured ahead of use.\n    return contextualLoggersByNameMap[name] || (contextualLoggersByNameMap[name] = new ContextualLogger(merge({\n      name: name\n    }, globalLogger.context)));\n  }; // CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\n  // write to the window's console object (if present); the optional options object can be used to customise the\n  // formatter used to format each log message.\n\n\n  Logger.createDefaultHandler = function (options) {\n    options = options || {};\n\n    options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\n      // Prepend the logger's name to the log message for easy identification.\n      if (context.name) {\n        messages.unshift(\"[\" + context.name + \"]\");\n      }\n    }; // Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\n    // that don't offer a native console method.\n\n\n    var timerStartTimeByLabelMap = {}; // Support for IE8+ (and other, slightly more sane environments)\n\n    var invokeConsoleMethod = function invokeConsoleMethod(hdlr, messages) {\n      Function.prototype.apply.call(hdlr, console, messages);\n    }; // Check for the presence of a logger.\n\n\n    if (typeof console === \"undefined\") {\n      return function () {\n        /* no console */\n      };\n    }\n\n    return function (messages, context) {\n      // Convert arguments object to Array.\n      messages = Array.prototype.slice.call(messages);\n      var hdlr = console.log;\n      var timerLabel;\n\n      if (context.level === Logger.TIME) {\n        timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\n\n        if (messages[1] === 'start') {\n          if (console.time) {\n            console.time(timerLabel);\n          } else {\n            timerStartTimeByLabelMap[timerLabel] = new Date().getTime();\n          }\n        } else {\n          if (console.timeEnd) {\n            console.timeEnd(timerLabel);\n          } else {\n            invokeConsoleMethod(hdlr, [timerLabel + ': ' + (new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms']);\n          }\n        }\n      } else {\n        // Delegate through to custom warn/error loggers if present on the console.\n        if (context.level === Logger.WARN && console.warn) {\n          hdlr = console.warn;\n        } else if (context.level === Logger.ERROR && console.error) {\n          hdlr = console.error;\n        } else if (context.level === Logger.INFO && console.info) {\n          hdlr = console.info;\n        } else if (context.level === Logger.DEBUG && console.debug) {\n          hdlr = console.debug;\n        } else if (context.level === Logger.TRACE && console.trace) {\n          hdlr = console.trace;\n        }\n\n        options.formatter(messages, context);\n        invokeConsoleMethod(hdlr, messages);\n      }\n    };\n  }; // Configure and example a Default implementation which writes to the `window.console` (if present).  The\n  // `options` hash can be used to configure the default logLevel and provide a custom message formatter.\n\n\n  Logger.useDefaults = function (options) {\n    Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);\n    Logger.setHandler(Logger.createDefaultHandler(options));\n  }; // Createa an alias to useDefaults to avoid reaking a react-hooks rule.\n\n\n  Logger.setDefaults = Logger.useDefaults; // Export to popular environments boilerplate.\n\n  if (typeof define === 'function' && define.amd) {\n    define(Logger);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Logger;\n  } else {\n    Logger._prevLogger = global.Logger;\n\n    Logger.noConflict = function () {\n      global.Logger = Logger._prevLogger;\n      return Logger;\n    };\n\n    global.Logger = Logger;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"module"}